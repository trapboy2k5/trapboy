#!/usr/bin/env python3
import os
import re
import select
import subprocess
import sys
import time
import base64


OK_MARK = b"ok! here is your flag!!\n"
PROMPT_MARK = b"input your answer:"

EXPR_RE = re.compile(r"^\([0-9+\-()]+\)$")


def safe_eval(expr: str) -> int:
    expr = expr.strip()
    if not EXPR_RE.fullmatch(expr):
        raise ValueError(f"unexpected expression: {expr!r}")
    return int(eval(expr, {"__builtins__": {}}, {}))


def read_available(fd: int, timeout_s: float) -> bytes:
    r, _, _ = select.select([fd], [], [], timeout_s)
    if not r:
        return b""
    try:
        return os.read(fd, 4096)
    except OSError:
        return b""


def recv_until(fd: int, needle: bytes, *, timeout_s: float, max_bytes: int = 256_000) -> bytes:
    buf = bytearray()
    start = time.time()
    while needle not in buf:
        if (time.time() - start) > timeout_s or len(buf) > max_bytes:
            break
        chunk = read_available(fd, 0.2)
        if not chunk:
            continue
        buf += chunk
    return bytes(buf)


def recv_n_after(fd: int, needle: bytes, n: int, *, timeout_s: float) -> bytes:
    buf = recv_until(fd, needle, timeout_s=timeout_s)
    idx = buf.find(needle)
    if idx == -1:
        return b""
    after = bytearray(buf[idx + len(needle) :])
    start = time.time()
    while len(after) < n and (time.time() - start) < timeout_s:
        chunk = read_available(fd, 0.2)
        if not chunk:
            continue
        after += chunk
    return bytes(after[:n])


def read_status_fields(pid: int | None = None) -> dict[str, str]:
    path = "/proc/self/status" if pid is None else f"/proc/{pid}/status"
    fields = {"NoNewPrivs": "-", "Uid": "-", "Gid": "-", "CapEff": "-"}
    try:
        with open(path, "r", encoding="utf-8", errors="replace") as f:
            for line in f:
                for k in list(fields.keys()):
                    if line.startswith(k + ":"):
                        fields[k] = line.split(":", 1)[1].strip()
    except Exception as e:
        fields["error"] = f"{type(e).__name__}: {e}"
    return fields


def root_mount_line() -> str:
    try:
        with open("/proc/mounts", "r", encoding="utf-8", errors="replace") as f:
            for line in f:
                parts = line.split()
                if len(parts) >= 4 and parts[1] == "/":
                    return line.strip()
    except Exception:
        pass
    return "-"


def cmd_out(cmd: list[str], timeout_s: float = 2.0) -> str:
    try:
        r = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout_s, check=False)
        out = (r.stdout or "") + (r.stderr or "")
        return out.strip()
    except Exception as e:
        return f"{type(e).__name__}: {e}"


def emit_diag() -> None:
    # Keep this short and stable: helps debug why /readflag can't open /flag under Codex/sandbox.
    print("DIAG: begin")
    print(f"DIAG: pid={os.getpid()} uid={os.getuid()} euid={os.geteuid()} gid={os.getgid()} egid={os.getegid()}")
    print("DIAG: self_status=" + " ".join(f"{k}={v}" for k, v in read_status_fields().items()))
    print("DIAG: root_mount=" + root_mount_line())
    print("DIAG: ls=" + cmd_out(["ls", "-l", "/readflag", "/flag"]))
    print("DIAG: stat=" + cmd_out(["stat", "-c", "%A %a %U:%G %n", "/readflag", "/flag"]))
    print("DIAG: end")


def main() -> int:
    emit_diag()

    # This is intentionally minimal: print one base64 line so Codex won't truncate it.
    p = subprocess.Popen(
        ["/readflag"],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=False,
        bufsize=0,
    )
    if p.stdin is None or p.stdout is None:
        print("RESULT: spawn error")
        return 0

    out_before = recv_until(p.stdout.fileno(), PROMPT_MARK, timeout_s=3.0)
    decoded = out_before.decode("utf-8", errors="replace")
    m = re.search(r"\n(\([0-9+\-()]+\))\s*\ninput your answer:", decoded)
    if not m:
        print("RESULT: protocol error (no expr)")
        print("RESULT_B64: " + base64.b64encode(out_before[:4096]).decode("ascii"))
        return 0

    ans = safe_eval(m.group(1))
    p.stdin.write((str(ans) + "\n").encode("ascii"))
    p.stdin.flush()

    # After answering, wait for the "ok! ..." line then read the next 72 bytes.
    fd = p.stdout.fileno()
    buf = recv_until(fd, OK_MARK, timeout_s=8.0)
    ok_found = OK_MARK in buf

    after = bytearray()
    if ok_found:
        after += buf.split(OK_MARK, 1)[1]

    start = time.time()
    while len(after) < 72 and (time.time() - start) < 8.0:
        chunk = read_available(fd, 0.2)
        if not chunk:
            # If the process already exited and there's nothing to read, stop.
            if p.poll() is not None:
                break
            continue
        after += chunk

    try:
        rc = p.wait(timeout=1.0)
    except Exception:
        rc = p.poll()

    # Best-effort snapshot of child status (it may have exited already).
    print("DIAG: child_status=" + " ".join(f"{k}={v}" for k, v in read_status_fields(p.pid if p.pid else None).items()))

    # One short status line + one base64 line.
    print(f"RESULT: ok_found={1 if ok_found else 0} after_len={len(after)} rc={rc if rc is not None else 'None'}")
    print("RESULT_B64: " + base64.b64encode(bytes(after[:72])).decode("ascii"))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
