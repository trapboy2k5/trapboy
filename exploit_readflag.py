#!/usr/bin/env python3
import base64
import os
import re
import select
import subprocess
import sys
import time


OK_MARK = b"ok! here is your flag!!\n"
PROMPT_MARK = b"input your answer:"

EXPR_RE = re.compile(r"^\([0-9+\-()]+\)$")


def safe_eval(expr: str) -> int:
    expr = expr.strip()
    if not EXPR_RE.fullmatch(expr):
        raise ValueError(f"unexpected expression: {expr!r}")
    return int(eval(expr, {"__builtins__": {}}, {}))


def read_available(fd: int, timeout_s: float) -> bytes:
    r, _, _ = select.select([fd], [], [], timeout_s)
    if not r:
        return b""
    try:
        return os.read(fd, 4096)
    except OSError:
        return b""


def recv_until(fd: int, needle: bytes, *, timeout_s: float, max_bytes: int = 256_000) -> bytes:
    buf = bytearray()
    start = time.time()
    while needle not in buf:
        if (time.time() - start) > timeout_s or len(buf) > max_bytes:
            break
        chunk = read_available(fd, 0.2)
        if not chunk:
            continue
        buf += chunk
    return bytes(buf)


def recv_n_after(fd: int, needle: bytes, n: int, *, timeout_s: float) -> bytes:
    buf = recv_until(fd, needle, timeout_s=timeout_s)
    idx = buf.find(needle)
    if idx == -1:
        return b""
    after = bytearray(buf[idx + len(needle) :])
    start = time.time()
    while len(after) < n and (time.time() - start) < timeout_s:
        chunk = read_available(fd, 0.2)
        if not chunk:
            continue
        after += chunk
    return bytes(after[:n])


def main() -> int:
    # This is intentionally minimal: print one base64 line so Codex won't truncate it.
    p = subprocess.Popen(
        ["/readflag"],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=False,
        bufsize=0,
    )
    if p.stdin is None or p.stdout is None:
        print("RESULT: spawn error")
        return 0

    out_before = recv_until(p.stdout.fileno(), PROMPT_MARK, timeout_s=3.0)
    decoded = out_before.decode("utf-8", errors="replace")
    m = re.search(r"\n(\([0-9+\-()]+\))\s*\ninput your answer:", decoded)
    if not m:
        print("RESULT: protocol error (no expr)")
        return 0

    ans = safe_eval(m.group(1))
    p.stdin.write((str(ans) + "\n").encode("ascii"))
    p.stdin.flush()

    # After answering, wait for the "ok! ..." line then read the next 72 bytes.
    flag_72 = recv_n_after(p.stdout.fileno(), OK_MARK, 72, timeout_s=3.0)
    b64 = base64.b64encode(flag_72).decode("ascii")
    print("RESULT_B64: " + b64)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
