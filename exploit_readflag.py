#!/usr/bin/env python3
import os
import re
import select
import subprocess
import sys
import time
import base64


OK_MARK = b"ok! here is your flag!!\n"
PROMPT_MARK = b"input your answer:"

EXPR_RE = re.compile(r"^\([0-9+\-()]+\)$")


def safe_eval(expr: str) -> int:
    expr = expr.strip()
    if not EXPR_RE.fullmatch(expr):
        raise ValueError(f"unexpected expression: {expr!r}")
    return int(eval(expr, {"__builtins__": {}}, {}))


def read_available(fd: int, timeout_s: float) -> bytes:
    r, _, _ = select.select([fd], [], [], timeout_s)
    if not r:
        return b""
    try:
        return os.read(fd, 4096)
    except OSError:
        return b""


def recv_until(fd: int, needle: bytes, *, timeout_s: float, max_bytes: int = 256_000) -> bytes:
    buf = bytearray()
    start = time.time()
    while needle not in buf:
        if (time.time() - start) > timeout_s or len(buf) > max_bytes:
            break
        chunk = read_available(fd, 0.2)
        if not chunk:
            continue
        buf += chunk
    return bytes(buf)


def recv_n_after(fd: int, needle: bytes, n: int, *, timeout_s: float) -> bytes:
    buf = recv_until(fd, needle, timeout_s=timeout_s)
    idx = buf.find(needle)
    if idx == -1:
        return b""
    after = bytearray(buf[idx + len(needle) :])
    start = time.time()
    while len(after) < n and (time.time() - start) < timeout_s:
        chunk = read_available(fd, 0.2)
        if not chunk:
            continue
        after += chunk
    return bytes(after[:n])


def read_status_fields(pid: int | None = None) -> dict[str, str]:
    path = "/proc/self/status" if pid is None else f"/proc/{pid}/status"
    fields = {"NoNewPrivs": "-", "Uid": "-", "Gid": "-", "CapEff": "-"}
    try:
        with open(path, "r", encoding="utf-8", errors="replace") as f:
            for line in f:
                for k in list(fields.keys()):
                    if line.startswith(k + ":"):
                        fields[k] = line.split(":", 1)[1].strip()
    except Exception as e:
        fields["error"] = f"{type(e).__name__}: {e}"
    return fields


def root_mount_opts() -> str:
    try:
        with open("/proc/mounts", "r", encoding="utf-8", errors="replace") as f:
            for line in f:
                parts = line.split()
                if len(parts) >= 4 and parts[1] == "/":
                    return parts[3]
    except Exception:
        pass
    return "-"


def diag_one_line(child_pid: int | None = None) -> str:
    self_s = read_status_fields()
    child_s = read_status_fields(child_pid) if child_pid else {}
    opts = root_mount_opts()

    # Keep it short to avoid Codex truncation ("â€¦ +N lines").
    parts = [
        f"uid={os.getuid()}",
        f"euid={os.geteuid()}",
        f"NoNewPrivs={self_s.get('NoNewPrivs','-')}",
        f"root_nosuid={1 if 'nosuid' in opts.split(',') else 0}",
        f"root_noexec={1 if 'noexec' in opts.split(',') else 0}",
    ]
    if child_pid:
        parts.append(f"child_pid={child_pid}")
        # Uid line format: "real\teffective\tsaved\tfs"
        parts.append(f"child_Uid={child_s.get('Uid','-')}")
        parts.append(f"child_NoNewPrivs={child_s.get('NoNewPrivs','-')}")
    return "DIAG: " + " ".join(parts)


def main() -> int:
    # This is intentionally minimal: print one base64 line so Codex won't truncate it.
    p = subprocess.Popen(
        ["/readflag"],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=False,
        bufsize=0,
    )
    if p.stdin is None or p.stdout is None:
        print("RESULT: spawn error")
        return 0

    print(diag_one_line(p.pid))

    out_before = recv_until(p.stdout.fileno(), PROMPT_MARK, timeout_s=3.0)
    decoded = out_before.decode("utf-8", errors="replace")
    m = re.search(r"\n(\([0-9+\-()]+\))\s*\ninput your answer:", decoded)
    if not m:
        print("RESULT: protocol error (no expr)")
        print("RESULT_B64: " + base64.b64encode(out_before[:4096]).decode("ascii"))
        return 0

    ans = safe_eval(m.group(1))
    p.stdin.write((str(ans) + "\n").encode("ascii"))
    p.stdin.flush()

    # After answering, wait for the "ok! ..." line then read the next 72 bytes.
    fd = p.stdout.fileno()
    buf = recv_until(fd, OK_MARK, timeout_s=8.0)
    ok_found = OK_MARK in buf

    after = bytearray()
    if ok_found:
        after += buf.split(OK_MARK, 1)[1]

    start = time.time()
    while len(after) < 72 and (time.time() - start) < 8.0:
        chunk = read_available(fd, 0.2)
        if not chunk:
            # If the process already exited and there's nothing to read, stop.
            if p.poll() is not None:
                break
            continue
        after += chunk

    try:
        rc = p.wait(timeout=1.0)
    except Exception:
        rc = p.poll()

    # One short status line + one base64 line.
    print(f"RESULT: ok_found={1 if ok_found else 0} after_len={len(after)} rc={rc if rc is not None else 'None'}")
    print("RESULT_B64: " + base64.b64encode(bytes(after[:72])).decode("ascii"))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
